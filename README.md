# USTCer's Y86-64
一个用 Python 实现的 Y86-64 指令集架构模拟器，支持五级流水线、数据冒险处理和基本汇编指令执行。
# 项目简介
USTCer's Y86-64 是一个完整的 Y86-64 指令集架构模拟器，实现了从汇编代码解析到流水线执行的完整流程。该项目使用 Python 编写，采用面向对象设计，通过位运算精确模拟 CPU 的底层操作，包括流水线、数据转发、冒险检测等核心功能。
# 主要特性
- 完整的 Y86-64 指令集支持
- 五级流水线模拟（取指、译码、执行、访存、写回）
- 数据冒险检测与气泡插入机制
- 二进制指令编码与解码
- 寄存器文件和内存系统模拟
- 条件码（标志位）处理
# 项目加载与安装
直接将本项目clone到本地，运行main.py
# 使用方法
运行后会自动弹出Assembly Language.txt，可在命令行中输入help查看帮助
# Y86-64 架构介绍
Y86-64 是一个简化的 64 位指令集架构，基于 x86-64 设计，用于教学和计算机体系结构研究。它保留了现代处理器的核心特性，同时大大简化了复杂度。
支持的指令集
### 1. 数据传输指令
```
irmovq V, rB    # 立即数到寄存器
rrmovq rA, rB   # 寄存器到寄存器
mrmovq D(rB), rA # 内存到寄存器
rmmovq rA, D(rB) # 寄存器到内存
```
### 2. 算术逻辑指令
```
addq rA, rB     # 加法
subq rA, rB     # 减法
andq rA, rB     # 与运算
xorq rA, rB     # 异或运算
```
### 3. 控制流指令
```
jmp Dest        # 无条件跳转
jle Dest        # 小于等于时跳转
jl Dest         # 小于时跳转
je Dest         # 等于时跳转
jne Dest        # 不等于时跳转
jge Dest        # 大于等于时跳转
jg Dest         # 大于时跳转
call Dest       # 过程调用
ret             # 过程返回
```
### 4. 条件传送指令
```
cmovle rA, rB   # 小于等于时传送
cmovl rA, rB    # 小于时传送
cmove rA, rB    # 等于时传送
cmovne rA, rB   # 不等于时传送
cmovge rA, rB   # 大于等于时跳转
cmovg rA, rB    # 大于时传送
```
### 5. 其他指令
```
pushq rA        # 压栈
popq rA         # 出栈
nop             # 空操作
halt            # 停止处理器
```
## 寄存器文件
Y86-64 提供 15 个 64 位寄存器：
- %rax - 返回值寄存器
- %rcx, %rdx, %rbx - 通用寄存器
- %rsp - 栈指针
- %rbp - 基址指针
- %rsi, %rdi - 源/目的索引寄存器
- %r8 - %r14 - 额外通用寄存器
## 条件码
- ZF: 零标志（结果为零时置位）
- SF: 符号标志（结果为负时置位）
- OF: 溢出标志（溢出时置位）

# 项目实现细节
## 流水线设计
模拟器实现了经典的五级流水线：
- 取指（Fetch）：从内存读取指令，更新PC
- 译码（Decode）：解析指令，读取寄存器值
- 执行（Execute）：执行算术逻辑运算
- 访存（Memory）：读写内存数据
- 写回（Writeback）：将结果写回寄存器
## 数据冒险处理
当前版本通过插入气泡的方式解决数据冒险。当检测到以下冒险时，流水线会自动暂停：
- RAW（写后读）冒险
- 控制冒险（分支预测错误）
## 二进制处理
项目实现了完整的二进制处理类，支持：
- 64位整数与字节数组的相互转换
- 有符号数的补码表示
- 位运算模拟ALU操作
- 指令的编码与解码
# 项目不足与后续更新方向
- 目前程序的异常处理并不完善，后期需改善
- 程序的内存读取目前只能从特定地址开始（8的倍数），无法做到真正连续的读取
- 数据冒险的处理使用插入气泡的方法，并未实现最高效率的转发
- 读取内存时总是从头开始寻找匹配地址，效率较低
# 许可证
本项目采用 MIT 许可证。详见 LICENSE 文件。
# 贡献
欢迎提交 Issue 和 Pull Request 来帮助改进这个项目。
# 致谢
感谢 CMU 的 CS:APP 课程提供的 Y86-64 架构设计
